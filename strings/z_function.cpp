/*
Привидение Петя любит играть со своими кубиками. Он любит выкладывать их в ряд 
и разглядывать свое творение. Однако недавно друзья решили подшутить над Петей 
и поставили в его игровой комнате зеркало. Ведь всем известно, что привидения 
не отражаются в зеркале! А кубики отражаются. Теперь Петя видит перед собой N
цветных кубиков, но не знает, какие из этих кубиков настоящие, а какие — всего 
лишь отражение в зеркале. Помогите Пете! Выясните, сколько кубиков может быть 
у Пети. Петя видит отражение всех кубиков в зеркале и часть кубиков, которая 
находится перед ним. Часть кубиков может быть позади Пети, их он не видит.
Входные данные
Первая строка входного файла содержит число N (1≤N≤10^6) и количество различных 
цветов, в которые могут быть раскрашены кубики — M (1≤M≤10^6). 
Следующая строка содержит N целых чисел от 1 до M — цвета кубиков.
Выходные данные
Выведите в выходной файл все такие K, что у Пети может быть K кубиков 
в подрядке возрастания.
*/

#include <iostream>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <algorithm>

using namespace std;

int main() {
  int n;
  int m;
  cin >> n >> m;

  vector<int> a(2 * n);
  for (int i = 0; i < n; ++i) {
    cin >> a[i];
    a[2 * n - 1 - i] = a[i];
  }

  vector<int> zFunc(a.size());
  zFunc[0] = a.size();
  int left = 0;
  int right = 0;
  for (int i = 1; i < a.size(); ++i) {
    zFunc[i] = max(0, min(right - i, zFunc[i - left]));
    while (i + zFunc[i] < a.size() && a[zFunc[i]] == a[i + zFunc[i]]) {
      ++zFunc[i];
    }
    if (i + zFunc[i] > right) {
      left = i;
      right = i + zFunc[i];
    }
  }
  
  for (int i = n; i < 2 * n; ++i) {
    if (zFunc[i] == 2 * n - i && (2 * n - i) % 2 == 0) {
      cout << n - zFunc[i] / 2 << ' ';
    }
  }
  cout << n << endl;
}